// import {depthFirstTraverseGraphEdges} from 'graph-adt'
import { depthFirstTraverseGraphEdges } from '../../graph-adt/src'
import { INIT_STATE } from "./properties"

function generateTestsFromFSM(fsm, generators, settings) {
  const tracedFSM = traceFSM(fsm);
  const genMap = getGeneratorMapFromGeneratorMachine(generators);

  // TODO
  // build a graph from the tracedFSM
  const fsmGraph = convertFSMtoGraph(tracedFSM);
  // search that graph with the right parameters
  const startingEdge = makeFakeEdge(INIT_STATE);
  const results = {
    empty: [],
    add : (searchResults, graph, newPathTraversalState, graphTraversalState) => {
      // TODO generated input sequence will be in edgesPaths, edgePathState
    }
  };
  const search = {
    isGoalReached: (edge, graph, newPathTraversalState, graphTraversalState) => {
      // TODO : reached when traversal criteria satisfied (for instance all paths)
    },
    isTraversableEdge: (edge, graph, newPathTraversalState, graphTraversalState) => {
      // TODO : false if gen cannot generate output, beware no output should be in edgepathstate already
      // TODO : initialEdgesPathState = { inputSequence: [], noMoreInputs: false } to put in client function
    },
  };
  const visit = {
    // TODO : initialEdgesPathState = { inputSequence: [], noMoreInputs: false } to put in client function
    initialEdgesPathState: {path: [], inputSequence : [], outputSequence: [], noMoreInput:false},
    // TODO : should compute inputSequence from gen, and fill noMoreInputs
    visitEdge: (edge, pathTraversalState, graphTraversalState) => {
      // NOTE : edge is a transition of the state machine
      const {path, inputSequence, outputSequence} = pathTraversalState;
      // Execute the state machine with the input sequence to get it in the matching control state
      // That gives us control state, and extended state
      // Then get the generator matching the control state, and the edge transition
      // Run this generator with the extended state to see if therer is results
      // if there is no results then `noMoreInputs : true`
      // else add to inputSequence the input generated by the generator
      // and add to outputSequence the output generated by the machine fed that input
      // NOTE : I will have to recereate the state machine every time?? TODO : find a way to have it in the traversal
      // maybe I can use th eindex information from the edte transition, and if 0 reuse, it not recompute?

      return {
        path : path.concat([edge])
      }
    }
  };
  const traverse = {
    results,
    search,
    visit
  };
  const testCases = depthFirstTraverseGraphEdges(traverse, startingEdge, fsmGraph);

  return testCases
}

/**
 * given a FSM F, instrument that FSM to output in addition to its usual actions also its control
 state, extended state, -and an array of its transitions-NO-, to keep referential equality, take
 directly the reference of guards.forEach : it should have a to, predicate, action.
 */
function traceFSM() {
  // TODO
}

// - GenMap of generator get :: ControlState -> Transition -> EventGenerator TODO
function getGeneratorMapFromGeneratorMachine(generators) {
  // TODO
}


// API
// generateTestsFromFSM(fsm, generators, settings) : Array<TestCase>
// fsm :: FSM_Def
// generators :: FSM_Gen_Def
// settings :: *
// TestCase :: {input :: InputSequence, actual :: OutputSequence}
//
// A. FSM_Gen_Def
/**
 * @typedef {Object} FSM_Gen_Def
 * @property {Array<GenTransition>} generators An array of transitions associated to an input generator for the sut
 */
/**
 * @typedef {Object} GenTransition
 * @property {Array<GenTransitionFromState>} An array of transitions from a specific origin control state, including
 * input generators
 */
/**
 * @typedef {{from: ControlState, event: Event, guards: Array<GenSpecs>}} GenTransitionFromState Transition for the
 * specified state is contingent to some guards being passed. Those guards are defined as an array.
 */
/**
 * @typedef {{predicate: Predicate, gen: InputGenerator, to: ControlState}} GenSpecs Specifies a generator `gen`
 * which will be responsible for computing inputs which pass the predicate, triggering a transition to `to` control
 * state.
 */
/**
 * @typedef {function (ExtendedState) : LabelledEvent | NoInput} InputGenerator generator which knows how to generate an
 * input, taking into account the extended state of the machine under test, after an input sequence has been run on
 * it. The generated input is generated so as to trigger a specific transition of the state machine. In the event,
 * it is not possible to generate the targeted transition of the state machine, the generator returns a value of
 * type `NoInput`.
 */
/**
 * @typedef {*} NoInput any object which unequivocally signifies an absence of input.
 */
/**
 * @typedef {{input :: InputSequence, actual :: OutputSequence}} TestCase
 */
/**
 * @typedef {Array<LabelledEvent>} InputSequence
 */
/**
 * @typedef {Array<MachineOutput>} OutputSequence
 */
