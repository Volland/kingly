// TODO import {depthFirstTraverseGraphEdges} from 'graph-adt'
import { depthFirstTraverseGraphEdges } from '../../graph-adt/src'
import { INIT_STATE } from "./properties"
import { lastOf } from "./helpers"
import * as Rx from "rx"
import { traceFSM } from "./synchronous_fsm"
const $ = Rx.Observable;

const settingsRx = {
  subject_factory: () => {
    const subject = new Rx.Subject();
    // NOTE : this is intended for Rxjs v4-5!! but should work for most also
    subject.emit = subject.next || subject.onNext;
    return subject
  },
  merge: function merge(arrayObs) {return $.merge(...arrayObs)},
  of: $.of,
};

function generateTestsFromFSM(fsm, generators, settings) {
  const tracedFSM = traceFSM({}, fsm);
  // associate a gen to from, event, guard index = the transition it is mapped
  // DOC : contract, all transition for a (from, event) must be gathered in one place
  const genMap = getGeneratorMapFromGeneratorMachine(generators);
  const { search } = settings;

  // TODO
  // build a graph from the tracedFSM
  const fsmGraph = convertFSMtoGraph(tracedFSM);
  // search that graph with the right parameters
  const startingEdge = makeFakeEdge(INIT_STATE);
  const visit = {
    // TODO : initialEdgesPathState = { inputSequence: [], noMoreInputs: false } to put in client function
    initialEdgesPathState: { path: [], inputSequence: [], outputSequence: [], noMoreInput: false, tracedFSM: void 0 },
    // TODO : should compute inputSequence from gen, and fill noMoreInputs
    visitEdge: (edge, graph, pathTraversalState, graphTraversalState) => {
      let noMoreInput = false;
      let newInputSequence;
      let newOutputSequence;
      // NOTE : edge is a transition of the state machine
      const { path, inputSequence, outputSequence} = pathTraversalState;
      // Execute the state machine with the input sequence to get it in the matching control state
      const fsm = create_state_machine(tracedFSM, fsmSettings);
      const tracedOutputSequence = inputSequence.map(fsm.yield);
      const {controlState, extendedState} = lastOf(tracedOutputSequence);
      const transition = getGeneratorMappedTransitionFromEdge(edge);
      const gen = genMap(controlState, transition);
      const {input : newInput, hasGeneratedInput }= gen(extendedState);
      if (!hasGeneratedInput) {
        noMoreInput = true;
        newInputSequence = inputSequence;
        newOutputSequence = outputSequence;
      }
      else {
        newInputSequence = inputSequence.concat(newInput);
        const newOutput = fsm.yield(newInput);
        newOutputSequence = outputSequence.concat(newOutput);
        noMoreInput = false;
      }
      // That gives us control state, and extended state
      // Then get the generator matching the control state, and the edge transition
      // Run this generator with the extended state to see if therer is results
      // if there is no results then `noMoreInputs : true`
      // else add to inputSequence the input generated by the generator
      // and add to outputSequence the output generated by the machine fed that input

      return {
        pathTraversalState: {
          path: path.concat([edge]),
          inputSequence : newInputSequence,
          outputSequence: newOutputSequence,
          noMoreInput
        },
        isTraversableEdge: !noMoreInput
      }
    }
  };
  const testCases = depthFirstTraverseGraphEdges(search, visit, startingEdge, fsmGraph);

  return testCases
}

// - GenMap of generator get :: ControlState -> Transition -> EventGenerator TODO
/**
 * from, event, index : CONTRACT : all transition from `from` triggered by `event` must be defined together in the
 * same record
 * TODO : write the contract when creating the state machine
 * CONTRACT : cannot have the same predicate for a same (from, event) as is logical, the second is contracdictory or
 * redundant
 * @param {FSM_Gen_Def} generators
 */
function getGeneratorMapFromGeneratorMachine(generators) {
  const genMap = new Map();
  generators.forEach(genTransition => {
    let {from, event, to, gen, guards} = genTransition;
    // Edge case when no guards are defined
    if (!guards){
      guards = [{to, gen, predicate : undefined, }]
    }
    guards.forEach((guard, guardIndex) => {
      const {to, gen, predicate} = guard;
      genMap.set({from, event, guardIndex}, gen);
    });
  });

  return genMap
}

/**
 * Returns the graph structure associated to the FSM
 * @param {FSM_Def} tracedFSM
 * @returns Graph
 */
function convertFSMtoGraph(tracedFSM){
  const {initial_extended_state, events, states, transitions} = tracedFSM;
  const vertices =
  const settings = {
    getEdgeTarget,
    getEdgeOrigin,
    constructEdge
  };
  return constructGraph(settings, edges, vertices)
}

// API
// generateTestsFromFSM(fsm, generators, settings) : Array<TestCase>
// fsm :: FSM_Def
// generators :: FSM_Gen_Def
// settings :: *
// TestCase :: {input :: InputSequence, actual :: OutputSequence}
//
// A. FSM_Gen_Def
/**
 * @typedef {Object} FSM_Gen_Def
 * @property {Array<GenTransition>} generators An array of transitions associated to an input generator for the sut
 */
/**
 * @typedef {Object} GenTransition
 * @property {Array<GenTransitionFromState>} An array of transitions from a specific origin control state, including
 * input generators
 */
/**
 * @typedef {{from: ControlState, event: Event, guards: Array<GenSpecs>}} GenTransitionFromState Transition for the
 * specified state is contingent to some guards being passed. Those guards are defined as an array.
 */
/**
 * @typedef {{predicate: Predicate, gen: InputGenerator, to: ControlState}} GenSpecs Specifies a generator `gen`
 * which will be responsible for computing inputs which pass the predicate, triggering a transition to `to` control
 * state.
 */
/**
 * @typedef {function (ExtendedState) : LabelledEvent | NoInput} InputGenerator generator which knows how to generate an
 * input, taking into account the extended state of the machine under test, after an input sequence has been run on
 * it. The generated input is generated so as to trigger a specific transition of the state machine. In the event,
 * it is not possible to generate the targeted transition of the state machine, the generator returns a value of
 * type `NoInput`.
 */
/**
 * @typedef {*} NoInput any object which unequivocally signifies an absence of input.
 */
/**
 * @typedef {{input :: InputSequence, actual :: OutputSequence}} TestCase
 */
/**
 * @typedef {Array<LabelledEvent>} InputSequence
 */
/**
 * @typedef {Array<MachineOutput>} OutputSequence
 */
